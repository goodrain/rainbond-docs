---
title: How do I don't write YAML to manage Kubernetes apps?
description: Kubernetes abstracts everything within its borders as a resource.The main part of this is the workload controller, represented by Deemployment, StatefulSet, around which all other resources revolve around these major resources
slug: noyaml
image: https://grstatic.oss-cn-shanghai.aliyuncs.com/wechat/import-exist-resource-to-rainbond/import-exist-resource-to-rainbond-1.png
---

Kubernetes abstracts everything within its borders as a resource.The main part of this is the workload controller, represented by Deemployment, StatefulSet, around which all other resources rest.These resources are combined, and IT technicians can display a workload-centred model.All resources in Kubernetes edit descriptions through a declaratory configuration file, a section of the Yaml field definition that gives IT technicians maximum freedom and places a very high demand on their capabilities.

## Simplify Kubernetes management through application models

When your team has used native Kubernetes for some time, most of you will find that not every IT technician is good at writing a complex Kubernetes declaration profile (YAML).For developers, in particular, their primary responsibility is business development, learning and writing YAML increases their burden and may even conflict with use.

The Open Source Project Rainbond is a cloud native application management platform that uses the design mode of **App-Centred**.This design mode reabstracts a higher level of application models than workload.There is no need to learn and write YAML from the experience used to achieve the full life cycle management of business applications.Application corresponds to a full business system consisting of several services components that can be managed individually. Deploying business components can be mirrored from source code and container, edit service call relationships by dragging them.Each service component can use common dimensions based on the graphical interface definition.On this basis, users can also use the core concept of the application model to perform more advanced operations. By publishing the entire business system in the form of an application template, the business system can be installed.In the area of software delivery, this capability is very useful, both online and offline in the final delivery environment, allowing for rapid and even individualized delivery based on application templates.

![](https://grstatic.oss-cn-shanghai.aliyuncs.com/wechat/import-exist-resource-to-rainbond/import-exist-resource-to-1.png)

The application models used by Rainbond make it easier for developers to focus on applications and operations themselves.The wiki features left behind when cropped are displayed and interacted through the graphical interface, greatly reducing the difficulty of using them, and using Kubernetes smoothly by applying templates without having to edit complex declaratory profiles.

## Convert YAML from Kubernetes to Application Model

The entire conversion process can be summarized as three steps：

1. For developers, most commonly used workloads, auto-generated from source and container imaging or imported YAML and running applications, the import process automatically identifies all convertible workload type resources, including Deemployment, StatefulSet, Job, CronJob types.These resources will be converted into an application model, which will then run as a service component.
2. After importing the generated service components, the basic Workload properties can be viewed and edited via the interface, such as environment variables, mirror addresses, etc.This will add identified advanced Workload properties to the service component, view and manage them in Key/Value or Yaml.
3. Non-Workload resource types, such as Secretaries, ServiceAccount, Role and others, will be categorized and loaded on the `k8s` page of the app interface to edit it in an interactive experience.

Advanced Workload properties that can be admin and converted include：

|   Attribute Name   | Role                                                                                                                                              |
| :----------------: | :------------------------------------------------------------------------------------------------------------------------------------------------ |
|    nodeSelector    | Node Selector：specifies some type of nodal to use.                                                                                |
|       labels       | The tag：is used to customize the label for the service component to be used by the selector.                                      |
|       Volumes      | Storage volume：is used to define the type of volume that is not managed by Rainbond                                                               |
|    volumeMounts    | Mount volume：is used with volumes to mount the volume to the container.                                                           |
|      affinity      | Parenthood：is more advanced in terms of movement control, including nodal affinity and Pod affinity                                               |
|     tolerations    | Tolerance：is used with node's stamps, Pod with a specified tolerance before scheduling to a specific node.                        |
| ServiceAccountName | The service account name：specifies an existing SA for the service component, giving certain permissions to the Pod.               |
|       prived       | Privileges mode：is properly configured and unnecessary.                                                                           |
|         env        | Environment variable：is used to define environmental variables that are not managed by Rainbond and supports referencing actions. |

Notably, the expanded RAM model can still be published as an application template for the next key install/upgrade/delivery of the entire business system.

## Import tests and practices that have been applied by Kubernetes

The following tests are based on Rainbond v5.8. In order to test Kubernetes for imported applications, I plan to conduct an import test using the `Wordpress` installation system that has been deployed in the `wp` naming space.This system consists of the following resources in：

```bash
[root@localhost ~]# kubtl get secret,service,employment,statefulset, d -n wp
NAME TYPE DATA AGE
secret/default-token-nq5rs kubernetes. o/service-account-token 3 27m
secret/mysql-secret Opaque 2 27m
NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE
service/wordpress NodePort 10. 3.157. 0    <none>        8080:30001/TCP 5m19 s
service/wp-mysql ClusterIP 10. 3.132 23   <none>        3306/TCP 27m
NAME READY UP-TO-DATE AVAILABLE AGE
employment. pps/wordpress 1/1 1 5m19s
NAME READY AGE
statefulset. pps/wp-mysql 1/1 27m
NAME READY STATUS RESTARTS AGE
pod/wordpress-66bc994449-qv97v 1/1 Running 0 5m19 s
pod/wp-mysql-0 1/1 Running 0 27m
```

Visit Rainbond and select import from the cluster. In this page, the namespace `wp` to import the resource.The platform will group resources by label into：

![](https://grstatic.oss-cn-shanghai.aliyuncs.com/wechat/import-exist-resource-to-rainbond/import-exist-resource-to-3.png)

Rainbond divides the application according to the `label` defined by the resource, and if it matches the `app.kubernetes.io/name:wp-mysql ` or `app:wordpress` resources are distributed to two different apps in the graph without the `label` resources mentioned above, it is divided into an ungrouped app.The division of the app is critical, as the advanced application of the model is for an app as a whole, so it must be carefully planned to add a reasonable `label` before import.

During the import process, Rainbond placed different properties under extended model management, most shipping operations have become easy to use, while the other part is managed on the Kubernetes attribute page.

![](https://grstatic.oss-cn-shanghai.aliyuncs.com/wechat/import-exist-resource-to-rainbond/import-exist-resource-to-2.png)

Once the import has been completed, both the `wordpress` and `wp-mysql` apps can use Rainbond to manage.

- Port management

`wordpress` presupposes `Service` of the `NodePort` type before being imported, but after importing Rainbond management, it can expose its 80 ports externally via the gateway.Note that you must reboot the `wordpress` service component to make the access policy effective.

![](https://grstatic.oss-cn-shanghai.aliyuncs.com/wechat/import-exist-resource-to-rainbond/import-exist-resource-to-4.png)

For some operations, the entry to visit does not support dynamic designation, which requires changes from the business side to accommodate the new access entrance.For `Wordpress`, redefine the site address in the general option.

![](https://grstatic.oss-cn-shanghai.aliyuncs.com/wechat/import-exist-resource-to-rainbond/import-exist-resource-to-5.png)

- Storage management

This `wordpress` system is deployed, and all components are stored in the `hostpath` mode. This configuration is simple, but is not suitable for a potentially drift Kubernetes environment where `Pod` may occur.When deployed, Rainbond will provide easy-to-use shared storage, which supports shared data between multiple Pods, and migration of Pod across hosts.Old hostpath storage, can be redefined.Redefined storage path will be empty, so remember to find new and old different paths and perform a data migration.

![](https://grstatic.oss-cn-shanghai.aliyuncs.com/wechat/import-exist-resource-to-rainbond/import-exist-resource-to-6.png)

## In the future

By applying models, IT technicians can be more interested in the business itself than in the use of complex tools at the bottom.The end result would be to simplify operating costs and comprehensiveness and make Kubernetes more easily accessible.
